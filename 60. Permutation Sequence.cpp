//https://leetcode.com/problems/permutation-sequence/submissions/

class Solution {
public:
    string getPermutation(int n, int k) {
        
        string result;
        
        int number;
        
        int amount = n;
        
        int sn;
        
        int j;
            
        int factorial [10];
        factorial [0] = 1;
        for (int i = 1; i <= 9; ++i)
            factorial [i] = factorial [i - 1] * i;
        
        int dif = int ('0');
        
        bool presence [amount + 1];                     //массив использованности цифры
        for (int i = 1; i <= n; ++i)
            presence [i] = 0;
        
        for (int i = 1; i <= amount - 1; ++i)
        {
            sn = (k - 1) / factorial [n - 1] + 1;       //порядковый номер числа которое надо поставить из имеющихся
                                                        //почему именно так: если k < n, берём первое свободное число
                                                        //алгоритм основан так: для n чисел кол-во перестановок 
                                                        //с первым числом "1" = (n-1)! => если k меньше, чем (n-1)!,
                                                        //то первое число будет минмальным из доступных, так и делаем
                                                        //до тех пор, пока у нас не будет ситуации, когда следующая цифра 
                                                        //идёт не по порядку, то бишь возникает перестановка
                                                        //для примера это случаи с n=3 -> "213" - "321"
                                                        //если для n=3 возникают первая и вторая перестановки, то бишь
                                                        //"123" и "132", то мы их не рассматриваем, как перестановки трёх
                                                        //а ставим минимальную доступную цифру и идём дальше (n -= 1)
                                                        //и также рассматриваем дальше, как для n=2, но уже с доступными
                                                        //нам цифрами (в данном примере мы поставили "1" => 
                                                        //свободны 2 и 3) и мы так же для них рассматриваем дальше 
                                                        //перестановки, как для двух, то есть возможно "12" и "21",
                                                        //но во всех случаях это не есть цифры, которые надо поставить,
                                                        //а порядковый номер доступной цифры, то если перестановка "21"
                                                        //поставит дальше вторую из доступных цифр 
                                                        //(обход, разумеется, снизу), и в нашем случае вторая доступная -
                                                        //"3", а первая доступная "2" так и ставим
                                                        //на словах с картинками проще объяснить, и я вообще хз зачем
                                                        //сейчас это написал, ибо мне это не поможет ничего вспомнить
                                                        //¯\_(ツ)_/¯
            
            if (sn > n)                                 //используется в случаях с крайними к n! значениями
                sn = ((sn - 1) % n) + 1;
            number = 1;
            while (sn != 0)                             //ищем свободное число нужного порядка
                if (presence [number] == 0)
                {
                    sn -= 1;
                    if (sn != 0)
                        number += 1;
                }
                else
                    number += 1;
            result.push_back (char (number + dif));
            presence [number] = 1;
            if (k > factorial [n - 1])
                k -= factorial [n - 1];
            n -= 1;
        }
        for (int i = 1; i <=amount; ++i)                    //добавляем последнюю цифру
            if (presence [i] == 0)
            {
                result.push_back (char (i + dif));
                return result;
            }
        
        /*while (n >= 0)
        {
            if (k == 0)
            {
                for (int i = 1; i <= amount; ++i)
                    if (presence [i] == 0)
                        
            }
            number = (k - 1) / factorial [n - 1] + 1;
            while (presence [number] != 0)
            {
                number += 1;
            }
            result.push_back (char (number + dif));
            presence [number] = 1;
            
        }
            
        result.push_back (char (k / factorial [n - 1] + 1 + dif));
        
        presence [k / factorial [n - 1] + 1] = 1;
        
        int i = k % n;*/
        return result;
    }
};
    
